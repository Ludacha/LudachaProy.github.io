<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>M茅todos Num茅ricos: Heun y Runge-Kutta</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 text-gray-800 font-sans">

  <header class="bg-purple-500 text-white p-6 shadow-md">
    <h1 class="text-3xl font-bold text-center">PROYECTO FINAL</h1>
    <h1 class="text-3xl font-bold text-center">Menu</h1>
    <section class="grid grid-cols-1 md:grid-cols-3 gap-4">
  <button onclick="mostrarSeccion('ejercicio37')" class="bg-blue-500 hover:bg-yellow-600 text-white font-semibold px-4 py-2 rounded">
    Aplicacion 1
  </button>
  <button onclick="mostrarSeccion('ejercicio39')" class="bg-blue-400 hover:bg-yellow-600 text-white font-semibold px-4 py-2 rounded">
    Aplicacion 2
  </button>
  <button onclick="mostrarSeccion('ejercicio40')" class="bg-blue-300 hover:bg-yellow-600 text-white font-semibold px-4 py-2 rounded">
    Aplicacion 3
  </button>
    </section>
  </header>

  <main class="max-w-4xl mx-auto mt-10 p-6 bg-white rounded-xl shadow-lg space-y-8">

    <section>
      <h2 class="text-2xl font-semibold mb-4">Introducci贸n</h2>
      <p class="text-lg leading-relaxed">
        Resumen del Proyecto: Soluci贸n de Problemas de Ingenier铆a y Ciencia Mediante la B煤squeda de Ra铆ces con M茅todos Num茅ricos <br> <br>

Este proyecto se enfoca en la aplicaci贸n de m茅todos num茅ricos para resolver problemas espec铆ficos en ingenier铆a y ciencia, encontrando las ra铆ces de las ecuaciones que los modelan. Resolveremos tres problemas concretos: <br> <br>

1. Encontrar el punto de operaci贸n de un diodo en un circuito el茅ctrico, utilizando la ecuaci贸n de Shockley. <br>
2. Optimizar una funci贸n de costo en un proceso de producci贸n, determinando el punto donde la derivada de la funci贸n de costo es cero. <br>
3. Modelar el equilibrio qu铆mico de una reacci贸n reversible, calculando las concentraciones de los reactivos y productos en el equilibrio. <br> <br>
Para abordar estos problemas, implementaremos y compararemos tres m茅todos num茅ricos: Bisecci贸n, Newton-Raphson y Secante. El proyecto incluye c贸digo Python para implementar los m茅todos, visualizaciones gr谩ficas de las funciones y las ra铆ces, y un an谩lisis comparativo del rendimiento de cada m茅todo. El c贸digo fuente est谩 disponible en un repositorio Git, y se ha creado una p谩gina web interactiva para permitir a los usuarios experimentar con los m茅todos y par谩metros. El objetivo es demostrar la utilidad pr谩ctica de estos m茅todos para resolver problemas reales en ingenier铆a y ciencia. <br>
      </p>
    </section>

    <section  id="ejercicio37" class="hidden bg-gray-100">
  <h3 class="text-xl font-semibold mt-6 mb-2 text-center">1. Dise帽o de Circuitos El茅ctricos (Diodo)</h3>
  <p class="text-center text-base mb-4">Problema</p>

  <div class="text-center text-base mb-4">
     Un diodo tiene una corriente de saturaci贸n inversa Is = 1e-12 A y un voltaje t茅rmico Vt = 0.026 V. Est谩 conectado en serie con una resistencia de R = 100 Ohmios y una fuente de voltaje de V = 5 V. Determina el voltaje en el diodo (Vd) utilizando el m茅todo de Newton-Raphson.
  </div>

  <h4 class="text-lg font-semibold mb-2 text-center">М C贸digo en Python</h4>
  <pre class="bg-gray-900 text-green-200 p-4 rounded overflow-auto text-sm"><code>
import numpy as np
import matplotlib.pyplot as plt

# Par谩metros del diodo
Is = 1e-12  # Corriente de saturaci贸n inversa (A)
Vt = 0.026  # Voltaje t茅rmico (V)
R = 100     # Resistencia (Ohmios)
V = 5       # Voltaje de la fuente (V)

# Ecuaci贸n del diodo (con resistencia en serie)
def diode_equation(Vd):
    return Is * (np.exp(Vd / Vt) - 1) + (Vd / R) - (V / R)

# Derivada de la ecuaci贸n del diodo
def diode_equation_derivative(Vd):
    return (Is / Vt) * np.exp(Vd / Vt) + (1 / R)

# M茅todo de Newton-Raphson
def newton_raphson(f, f_prime, x0, tol=1e-6, max_iter=100):
    x = x0
    iterations = [x0]
    for i in range(max_iter):
        fx = f(x)
        if abs(fx) < tol:
            return x, i + 1, iterations
        f_prime_x = f_prime(x)
        if f_prime_x == 0:
            print("Derivada es cero. Newton-Raphson fall贸.")
            return None, i + 1, iterations
        x = x - fx / f_prime_x
        iterations.append(x)
    print("Newton-Raphson no convergi贸.")
    return None, max_iter, iterations

# Estimaci贸n inicial
Vd_initial = 0.7  # Voltios

# Resolver la ecuaci贸n
Vd, iterations, all_iterations = newton_raphson(diode_equation, diode_equation_derivative, Vd_initial)

if Vd is not None:
    print(f"Voltaje del diodo (Vd): {Vd:.6f} V")
    print(f"N煤mero de iteraciones: {iterations}")

    # Graficar
    Vd_range = np.linspace(0, 0.8, 400)
    f_Vd = [diode_equation(v) for v in Vd_range]

    plt.figure(figsize=(8, 6))
    plt.plot(Vd_range, f_Vd, label="Ecuaci贸n del Diodo")
    plt.scatter(Vd, 0, color='red', label=f"Vd = {Vd:.3f} V")
    plt.xlabel("Voltaje del Diodo (Vd)")
    plt.ylabel("f(Vd)")
    plt.title("Punto de Operaci贸n del Diodo")
    plt.grid(True)
    plt.legend()
    plt.show()
else:
    print("No se encontr贸 la soluci贸n.")

  </code></pre>
  <p class="text-center text-base mb-4">Resultados.</p>

  <div class="text-center text-base mb-4">
    <p> Voltaje del diodo (vd): <strong class="font-mono">0.636974 V</strong></p>
    <p> Nro de iteraciones: <strong class="font-mono">7</strong></p>
  </div>
  <img src="img/img1.png" alt="">
</section>


<section id="ejercicio39" class="hidden bg-gray-50">
  <h3 class="text-xl font-semibold mt-6 mb-2 text-center">2. Optimizaci贸n en Ingenier铆a (Costo M铆nimo)</h3>
  <p class="text-center text-base mb-4">Problema</p>

  <div class="text-center text-base mb-4">
     Una empresa tiene una funci贸n de costo total dada por C(x) = x^4 - 6x^2 + 8x + 10, donde x es la cantidad de unidades producidas. Determina la cantidad de unidades que minimiza el costo total utilizando el m茅todo de la Secante.
  </div>

  <h4 class="text-lg font-semibold mb-2 text-center">М C贸digo en Python</h4>
  <pre class="bg-gray-900 text-green-200 p-4 rounded overflow-auto text-sm"><code>
import numpy as np
import matplotlib.pyplot as plt

# Funci贸n de costo
def cost_function(x):
    return x**4 - 6*x**2 + 8*x + 10

# Derivada de la funci贸n de costo
def cost_function_derivative(x):
    return 4*x**3 - 12*x + 8

# M茅todo de la Secante
def secant(f, x0, x1, tol=1e-6, max_iter=100):
    iterations = [x0, x1]
    for i in range(max_iter):
        fx0 = f(x0)
        fx1 = f(x1)
        if abs(fx1) < tol:
            return x1, i + 1, iterations
        if fx1 == fx0:
            print("Secante fall贸 (divisi贸n por cero).")
            return None, i + 1, iterations
        x2 = x1 - fx1 * (x1 - x0) / (fx1 - fx0)
        iterations.append(x2)
        x0 = x1
        x1 = x2
    print("Secante no convergi贸.")
    return None, max_iter, iterations

# Estimaciones iniciales
x0 = 0.0
x1 = 2.0

# Resolver la ecuaci贸n
x_min, iterations, all_iterations = secant(cost_function_derivative, x0, x1)

if x_min is not None:
    print(f"Cantidad de unidades que minimiza el costo: {x_min:.6f}")
    print(f"N煤mero de iteraciones: {iterations}")

    # Graficar
    x_range = np.linspace(-3, 3, 400)
    C_x = [cost_function(x) for x in x_range]

    plt.figure(figsize=(8, 6))
    plt.plot(x_range, C_x, label="Funci贸n de Costo C(x)")
    plt.scatter(x_min, cost_function(x_min), color='red', label=f"M铆nimo en x = {x_min:.3f}")
    plt.xlabel("Cantidad de Unidades (x)")
    plt.ylabel("Costo Total C(x)")
    plt.title("Optimizaci贸n de Costo")
    plt.grid(True)
    plt.legend()
    plt.show()
else:
    print("No se encontr贸 la soluci贸n.")

  </code></pre>
  <p class="text-center text-base mb-4">Resultados.</p>

  <div class="text-center text-base mb-4">
    <p> Cantidad de unidades que minimiza el costo: <strong class="font-mono">-2.000000</strong></p>
    <p> Nro de iteraciones: <strong class="font-mono">2</strong></p>
  </div>
  <img src="img/img2.png" alt="">
</section>


<section id="ejercicio40" class="hidden bg-gray-200 ">
  <h3 class="text-xl font-semibold mt-6 mb-2 text-center">3. Modelado de Reacciones Qu铆micas (Equilibrio)</h3>
  <p class="text-center text-base mb-4">Problema</p>

  <div class="text-center text-base mb-4">
     Considera la reacci贸n reversible A + B <=> C. Inicialmente, las concentraciones de A y B son A0 = 1.0 M y B0 = 1.0 M, respectivamente. La constante de equilibrio es K = 2.0. Determina la concentraci贸n de C en el equilibrio (x) utilizando el m茅todo de Bisecci贸n.
  </div>

  <h4 class="text-lg font-semibold mb-2 text-center">М C贸digo en Python</h4>
  <pre class="bg-gray-900 text-green-200 p-4 rounded overflow-auto text-sm"><code>
import numpy as np
import matplotlib.pyplot as plt

# Par谩metros de la reacci贸n
K = 2.0   # Constante de equilibrio
A0 = 1.0  # Concentraci贸n inicial de A (M)
B0 = 1.0  # Concentraci贸n inicial de B (M)

# Ecuaci贸n de equilibrio
def equilibrium_equation(x):
    return (x**2) / ((A0 - x) * (B0 - x)) - K

# M茅todo de Bisecci贸n
def bisection(f, a, b, tol=1e-6, max_iter=100):
    if f(a) * f(b) >= 0:
        print("La funci贸n no cambia de signo en el intervalo.")
        return None, None, []

    iterations = []
    for i in range(max_iter):
        c = (a + b) / 2
        iterations.append(c)
        if f(c) == 0 or (b - a) / 2 < tol:
            return c, i + 1, iterations

        if f(a) * f(c) < 0:
            b = c
        else:
            a = c

    print("Bisecci贸n no convergi贸.")
    return None, max_iter, iterations

# Intervalo inicial
a = 0.0
b = 0.9  # La concentraci贸n de C no puede ser mayor que la de A o B

# Resolver la ecuaci贸n
x, iterations, all_iterations = bisection(equilibrium_equation, a, b)

if x is not None:
    print(f"Concentraci贸n de C en el equilibrio: {x:.6f} M")
    print(f"N煤mero de iteraciones: {iterations}")

    # Graficar
    x_range = np.linspace(0, 0.9, 400)
    f_x = [equilibrium_equation(xi) for xi in x_range]

    plt.figure(figsize=(8, 6))
    plt.plot(x_range, f_x, label="Ecuaci贸n de Equilibrio")
    plt.scatter(x, 0, color='red', label=f"Concentraci贸n de C = {x:.3f} M")
    plt.xlabel("Concentraci贸n de C (x)")
    plt.ylabel("f(x)")
    plt.title("Equilibrio Qu铆mico")
    plt.grid(True)
    plt.legend()
    plt.show()
else:
    print("No se encontr贸 la soluci贸n.")

  </code></pre>
  <p class="text-center text-base mb-4">Resultados.</p>

  <div class="text-center text-base mb-4">
    <p> Concentraci贸n de C en el equilibrio: <strong class="font-mono">0.585787 M</strong></p>
    <p> Nro de iteraciones: <strong class="font-mono">20</strong></p>
  </div>
  <img src="img/img3.png" alt="">
</section>



    <section id="heun" class="hidden">
      <h3 class="text-xl font-semibold mt-6 mb-2">M茅todo de Heun</h3>
      <p class="text-base">
        El m茅todo de Heun es un m茅todo de segundo orden que calcula una predicci贸n inicial y luego la corrige:
        <br><br>
        <code>
          y<sub>p</sub> = y<sub>n</sub> + h路f(x<sub>n</sub>, y<sub>n</sub>) <br>
          y<sub>n+1</sub> = y<sub>n</sub> + (h/2)路[f(x<sub>n</sub>, y<sub>n</sub>) + f(x<sub>n+1</sub>, y<sub>p</sub>)]
        </code>
      </p>
    </section>

    <section id="rk4" class="hidden">
      <h3 class="text-xl font-semibold mt-6 mb-2">M茅todo de Runge-Kutta 4to Orden</h3>
      <p class="text-base">
        Este m茅todo usa cuatro pendientes ponderadas:
        <br><br>
        <code>
          k<sub>1</sub> = f(x<sub>n</sub>, y<sub>n</sub>) <br>
          k<sub>2</sub> = f(x<sub>n</sub> + h/2, y<sub>n</sub> + h路k<sub>1</sub>/2) <br>
          k<sub>3</sub> = f(x<sub>n</sub> + h/2, y<sub>n</sub> + h路k<sub>2</sub>/2) <br>
          k<sub>4</sub> = f(x<sub>n</sub> + h, y<sub>n</sub> + h路k<sub>3</sub>) <br><br>
          y<sub>n+1</sub> = y<sub>n</sub> + (h/6)(k<sub>1</sub> + 2k<sub>2</sub> + 2k<sub>3</sub> + k<sub>4</sub>)
        </code>
      </p>
    </section>

    <section id="comparacion" class="hidden">
  <h3 class="text-xl font-semibold mt-6 mb-4 text-center">Comparaci贸n entre Heun y Runge-Kutta</h3>

  <p class="text-base mb-6 text-center">
    El m茅todo de Heun es m谩s simple y computacionalmente m谩s r谩pido, pero menos preciso.<br>
    Runge-Kutta de 4to orden es m谩s costoso computacionalmente, pero mucho m谩s preciso en la mayor铆a de los casos.<br>
    Para aplicaciones donde se requiere alta precisi贸n sin reducir el paso, Runge-Kutta 4to es preferido.
  </p>

  <h4 class="text-lg font-semibold mb-4 text-center"> Resultados en Ejercicios Concretos</h4>

  <div class="overflow-x-auto">
    <table class="min-w-full border border-gray-300 text-center text-base">
      <thead class="bg-gray-100">
        <tr>
          <th class="px-4 py-2 border">Ejercicio</th>
          <th class="px-4 py-2 border">Resultado Heun</th>
          <th class="px-4 py-2 border">Resultado RK4</th>
          <th class="px-4 py-2 border">Observaci贸n</th>
        </tr>
      </thead>
      <tbody>
        <tr class="hover:bg-gray-50">
          <td class="px-4 py-2 border font-semibold">37: Crecimiento poblacional</td>
          <td class="px-4 py-2 border font-mono">4981.54</td>
          <td class="px-4 py-2 border font-mono">4981.73</td>
          <td class="px-4 py-2 border">Se aproxima al l铆mite <strong>NM = 5000</strong>, indicando saturaci贸n.</td>
        </tr>
        <tr class="hover:bg-gray-50">
          <td class="px-4 py-2 border font-semibold">39: Crecimiento del tumor</td>
          <td class="px-4 py-2 border font-mono">58.95</td>
          <td class="px-4 py-2 border font-mono">58.95</td>
          <td class="px-4 py-2 border">Estabiliza cerca del valor l铆mite <strong>k = 60 m虏</strong>.</td>
        </tr>
        <tr class="hover:bg-gray-50">
          <td class="px-4 py-2 border font-semibold">40: Ca铆da libre con resistencia</td>
          <td class="px-4 py-2 border font-mono">-31.32 m/s</td>
          <td class="px-4 py-2 border font-mono">-31.32 m/s</td>
          <td class="px-4 py-2 border">Velocidad se aproxima a la terminal por fricci贸n del aire.</td>
        </tr>
      </tbody>
    </table>
  </div>
</section>


  </main>

  <script>
    function mostrarSeccion(id) {
      document.querySelectorAll("main section[id]").forEach(sec => sec.classList.add("hidden"));
      document.getElementById(id).classList.remove("hidden");
    }
  </script>

</body>
</html>
